/*
学习笔记
*/

1.虚拟机的安装
	装虚拟机软件，虚拟出一台电脑，然后我们在虚拟的电脑上安装linux操作系统
	安装虚拟机的软件为：WMware-workstation           ///20

2.虚拟机中安装linux
	红帽子：收费，好用
	CentOS:被红帽子收购，免费
	Ubuntu:免费
	huan Uestc_liuhuan123
	安装过程如果卡主，重启安装即可

3.配置固定IP地址准备工作
	需要修改配置文件 vim工具。命令行：sudo apt-get install vim-gtk
	esc + shift + :///q!回车退出vim
	现在有两台主机（windows+linux）,IP地址不能相同，但是要在同一个网段中一个客服端，一个服务端
	本地：
    IPv4 地址 . . . . . . . . . . . . : 192.168.1.119
    子网掩码  . . . . . . . . . . . . : 255.255.255.0
    默认网关. . . . . . . . . . . . . : fe80::1%8
                                       192.168.1.1
	所以linux的IP位192.168.1.？？///126
	确定IP是否被占用，ping IP,查看是否能找到
	确定IP为192.168.1.126

4.配置服务器IP
	linux上查看网络信息：ifconfig(windows:ipconfig),网卡名ens33
	vim分文本编辑状态和命令状态，命令道文本要按i,反之按ESC，在命令状态下输入shift:wq!存盘退出，q!不存盘退出
	55min

5.修改DNS
	8.8.8.8谷歌域名解析服务器

6.配置远程链接
	(1)需要在linux上安装ssh服务 ps -elgrep ssh检查是否有安装ssh
	sudo apt-get install openssh-server
	远程连接工具，Xshell

 7.安装编译工具gcc(编译c程序)，g++(编译c++程序)
	sudo apt-get install build-essential
	sudo apt-get install gcc
	sudo apt-get install g++

 8.共享操作目录
	vim使用不习惯
	windows写代码，转到linux下编译
	samba服务，在这里不采用
	通过虚拟机，共享windows目录，linux可以访问

/*************************/
1. 安装nginx,搭建web服务器
	epoll,linux内核版本2.6以上
	gcc编译器，g++编译器
	pcre库：函数库，支持解析正则表达式 sudo apt-get install libpcre3-dev
	zlib库：压缩，解压缩功能 sudo apt-get install libz-dev
	openssl库：ssl功能相关库，用于网站加密通讯 sudo apt-get install libssl-dev

2. nainx源码下载及目录结构简单认识
	nginx官网: http://www.nginx.org
	版本：mainline,版本号中间数字一般为奇数，更新快，有最新功能有bug修复，稳定性差一点
		  stable，稳定版，中间数字一般为偶数，经过长时间测试比较稳定，一般用于商业环境
		  Legacy，遗留版本，以往老版本
	安装：有二进制版本，通过命令安装，不灵活
	      灵活安装，编译nginx，才能把三方模块装进来

	创建目录并将源码下载到linux
		mkdir nginxsourcecode
		ls
		wget http://nginx.org/download/nginx-1.14.2.tar.gz下载
		下载完成需要解压：tar -xzvf nginx-1.14.2.tar.gz

3. nginx源码目录
	auto/:编译相关的搅拌，可执行文件configure一会会用到这里面的脚本
		CC/:检查编译器的脚本
		lib/:检查依赖库的脚本
		os/:检查操作系统类型的脚本
		type/:检查平台类型的脚本
		cd ..返回上一级
	CHANGES:修复的bug，新增功能说明
	CHANGES.ru:俄语版
	conf/:默认的配置文件
	configure:编译之前用此可执行文件生成一些必要的中间文件
	contrib/:脚本和工具，典型的是vim高亮工具
	html/:欢迎界面和错误界面先关的html文件
	man/:命令行帮助文件
	src/:源码目录
		core:核心代码
		event:event(事件)相关代码
		http:http(服务)模块相关代码
		mail（邮件）模块相关代码
		os：操作系统相关代码
		stream：流处理相关代码

4. 编译nginux
	用configure来做编译之前的工作
	--prefix:指定最终安装目录，默认值：/usr/local/nginx
	--sbin-path:用来指定可执行文件目录：默认值是sbin/nginx
	--conf-path:用来指定配置文件目录:默认值conf/nginx.conf

	执行configure生成中间文件目录： ./configure
	objs/ngx_modules:内容决定了我们一会编译nginx的时候有哪些模块会被编译到nginx里面来
	Makefile:编译规则文件，执行make命令时用到

	make命令来编译，生成nainx可执行文件： make
	用make命令开始安装，把配置文件拷贝到安装目录 sudo make install

5.使用nginx
	启动：sudo ./nginx
	缺省的服务器默认是80端口

/**************四：nginx整体结构，进程模型*******************/
nginx整体结构：
	1.master进程和worker进程（父子关系）
	启动nginx后，看到一个master进程和worker进程
	ps -ef | grep nginx命令
	第一列：UID，进程所属用户ID
	第二列：进程ID（PID,用来唯一标识进程
	第三列：父进程ID，fork()创建进程，worker进程是master创建出来的

	2.nginx进程模型
	1个master进程，1到多个worker进程，这种工作机制对外服务，这种工作机制保证nginx稳定灵活运行
	master进程责任：监控进程，不处理具体业务，专门用于管理的监控worker进程
	worker进程：用来干活，和用户交互
	master和worker进程之间要通讯，可以用信号，也可以用共享内存;
	稳定性，灵活性体现之一：worker一旦挂掉，master会立即fork一个新的worker进程

	3.调整worker进程数量
	worker进程几个合适，有一个公认的做法：多核计算机，让每个worker运行在一个单独的内核上，最大限度减少CPU进程切换成本
	我的电脑是8核（8个processor）;
	grep -c processor /proc/cpuinfo查看虚拟机processor
	配置虚拟机processor数量
	配置nginx的processor的数量

nginx进程模型细说：
	稳定，灵活
	1.nginx配置文件重载
	kill 一个worker进程，master会立即fork一个新的worker进程（666）
	sudo kill 948

	2.nginx热升级
	运行时可以升级，不用停止nginx
	还可以回滚版本

	3.nginx的关闭
	sudo ./nginx -s quit：优雅退出
	sudo ./nginx -s stop:粗暴退出

总结：
	多线程模型弊端：共享内存，如果报错一定会影响其他线程，最终会导致服务器挂掉


/**************3.1：学习nginx源码钱的准备工作*******************/
nginx源码查看工具：vs code

nginx源码入口函数定位：nginx.c

创建一个自己的linux的c语言程序：
	如果共享目录不见了，一般是虚拟机自带工具 VMWare tools可能有问题
	重装VMWare tools:
	选择虚拟机->冲转VMWare tools
	sudo mkdir cdrom
	sudo mount /dev/cdrom  /mnt/cdrom
	sudo cp Wm.......gz ../
	sudo tar -zxvf vm......gz
	cd vmware-tools-distrib
	sudo ./vmware-install.pl

gcc编译程序：
	如果.c文件很多都需要编译，那需要专门写makefile来编译
	gcc -o:用来指定可执行文件名
	gcc -o nginx nginx.c
	
/**************3.2：nginx源码学法，终端和进程的关系说*******************/
ps命令
whereis命令

/**************3.3：信号的概念、认识、处理动作*******************/
信号的基本概念：
	进程之间的常用通信手段：发送信号
	信号：通知，通知某个进程发生了某一件事情，事情和信号都是突发事件，信号是异步发生的，信号也被称为”软中断“
	信号如何产生：某个进程发送给另外一个进程，或者发送给自己。
	由内核（操作系统）发送给某个进程：在键盘上输入命令ctrl+c(中断信号)，kill命令。内存访问异常，除数为0，硬件会检测到通知内核。
	信号名字：SIG开头，例如SIGHUP（终端断开信号）
	不同的类unix操作系统支持的信号数量各不相同
	信号都有名字，信号是一些整数常量，一般#include<signal>
	sudo find / -name "signal.h" | xargs grep -in "SIGHUP"
	通过kill命令认识一些信号：
		kill:他的工作发送信号给进程,STREAM(终止信号)
		能给进程发送多种信号,只是发送信号，不是单纯的杀死进程
		ps -eo pid,ppid,sid,tty,pgrp,comm | grep -E 'bash|PID|nginx'
		sudo strace -e trace=signal -p 1269
		kill -1(SIGHUP信号) 1318，能发出和枚举值对应的信号，不加参数默认-15
		查看进程状态：ps -eo pid,ppid,sid,tty,pgrp,comm,stat | grep -E 'bash|PID|nginx'

常用信号列举：

常用信号处理的相关动作：
	当某个信号出现时，我们可以按三种方式来处理。
	执行默认动作:比如停止，终止
	忽略此信号：SIGKILL,SIGSTOP不能被忽略
	捕捉信号：当信号来的时候用自己的处理函数处理SIGKILL和SIGSTOP除外

/**************3.4：linux体系结构，信号编程初步*******************/
用户态，内核态
shell和bash之间的关系
signal函数
可重入函数

/**************3.5：信号编程进阶、sigprocmask范例*******************/
信号集：
	一个进程必须能够记住当前阻塞了哪些信号
	我们需要被称为“信号集”的一种信号类型，能够把60多个信号都表示下:sigset_t
	//typedef struct{
	//     unsigned long sig[2];
	//}sigset_t;

信号相关函数：
	sigemptyset():清空信号集，把所有信号为清为0，表示这60多个信号都没有来
	sigfillset():把信号集中的信号都设置为1
	sigaddset(),sigdelset():把某个信号从0变成1，反之

	sigprocmask(),siigmember()
	一个进程里面有一个信号集，用来表示当前阻塞了哪些信号，把某个信号设为1表示阻塞同类信号，不能传递给该进程
	sigprocmask():设置该进程信号集中的内容

/**************3.6：fork函数详解，范例演示*******************/
	//一：fork()函数简单认识
	//创建进程；
	//进程的概念：一个可执行程序，执行起来就是一个进程，再执行起来一次，它就又是一个进程（多个进程可以共享同一个可执行文件）
	 //文雅说法：进程 定义为程序执行的一个实例；

	//在一个进程（程序）中，可以用fork()创建一个子进程，当该子进程创建时，
	     //它从fork()指令的下一条(或者说从fork()的返回处)开始执行与父进程相同的代码；

	//a)说白了：fork()函数产生了一个和当前进程完全一样的新进程，并和当前进程一样从fork()函数里返回；
	 //原来一条执行通路（父进程），现在变成两条（父进程+子进程）

	//fork()：一分二； *********
	//（1.1）fork()函数简单范例
	//ps -eo pid,ppid,sid,tty,pgrp,comm,stat | grep -E 'bash|PID|nginx'
	//fork()之后，是父进程fork()之后的代码先执行还是子进程fork()之后的代码先执行是不一定的；这个跟内核调度算法有关；
	//kill子进程，观察父进程收到什么信号:SIGCHLD信号 ，子进程变成了僵尸进程Z

	//（1.2）僵尸进程的产生、解决，SIGCHLD
	//僵尸进程的产生：在Unix系统中，一个子进程结束了，但是他的父进程还活着，
	              // 但该父进程没有调用(wait/waitpid)函数来进行额外的处置，那么这个子进程就会变成一个僵尸进程；
	//僵尸进程：已经被终止，不干活了，但是依旧没有被内核丢弃掉，因为内核认为父进程可能还需要该子进程的一些信息；
	//作为开发者，坚决不允许僵尸进程的存在；
	//如何干掉僵尸进程：
	 //a)重启电脑
	 //b)手工的把僵尸进程的父进程kill掉，僵尸进程就会自动消失；
	//SIGCHLD信号：一个进程被终止或者停止时，这个信号会被发送给父进程；
	 //所以，对于源码中有fork()行为的进程，我们 应该拦截并处理SIGCHLD信号；
	//waitpid();

	//二：fork()函数进一步认识
	//b)fork()产生新进程的速度非常快，fork()产生的新进程并不复制原进程的内存空间，而是和
	  //原进程（父进程)一起共享一个内存空间，但这个内存空间的特性是“写时复制”，也就是说：
	   //原来的进程和fork()出来的子进程可以同时、自由的读取内存，但如果子进程（父进程）对
	    //内存进行修改的话，那么这个内存就会复制一份给该进程单独使用，以免影响到共享这个内存空间的
	     //其他进程使用；

	//三：完善一下fork()代码
	//fork()回返回两次：父进程中返回一次，子进程中返回一次,而且，fork()在父进程中返回的值和在子进程中返回的值是不同的
	//子进程的fork()返回值是0；
	//父进程的fork()返回值是新建立的子进程的ID，因为全局量g_mygbltest的值发生改变，导致主，子进程内存被单独的分开，所以每个的
	   //g_mygbltest值也不同；

	//（3.1）一个和fork()执行有关的逻辑判断（短路求值）
	//||或：有1出1，全0出0；
	//&&与：全1出1，有0出0；

	//四：fork()失败的可能性
	//a)系统中进程太多
	//缺省情况，最大的pid：32767

	//b)每个用户有个允许开启的进程总数；
	//7788








		

