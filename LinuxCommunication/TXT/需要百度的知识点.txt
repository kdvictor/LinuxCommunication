WMware-workstation
一款可以虚拟计算机的软件

Linux 系统
RedHat:商用收费
CentOS：RedHat的复制版，不收费
Ubuntu：桌面型Linux

vim
文本编辑器：https://blog.csdn.net/yang1349day/article/details/88885480

IP地址
https://blog.csdn.net/apanious/article/details/51014374

网段
https://blog.csdn.net/lusijie1/article/details/78578147

子网掩码，网关
https://blog.csdn.net/faker_wang/article/details/80747407

ping命令
https://blog.csdn.net/hezeyujiang/article/details/79504038

DNS：域名解析
https://www.cnblogs.com/gopark/p/8430916.html

ssh服务
https://www.cnblogs.com/sunshine-long/p/8846044.html

xshell
gcc
g++

ls -la
cp -r 拷贝命令

MAKEFILE文件

ps命令
服务器程序端口号
监听端口号

/**************四：nginx整体结构，进程模型*******************/
1. 进程之间的通讯方式
2. CPU处理机数量

/**************3.1：学习nginx源码钱的准备工作*******************/
linux文件权限
gcc命令行参数
makefile了解一下

/**************3.2：nginx源码学法，终端和进程的关系说*******************/
nginx源码学习方法：
	跟着老师学，nginx中最有用的东西
	前期学习两个主要任务
	泛读nginx中的一些重要代码，把nginx中最重要的代码提取出来作为我们自己知识库的一部分

终端和进程的关系：
	1.终端与bash进程
	ps -rf | grep bash
	pts:虚拟终端，没连接一个虚拟终端到乌班图linux操作系统就会出现一个bash进程（shell
		用于解释用户输入的命令
	whereis bash

	2.终端上的开启进程
	pa -la
	终端关闭，终端上的进程也关闭了
	可执行程序nginx是bash的子进程
	每个进程还属于一个进程组：一个或者多个进程的组合，每一个进程组有一个进程组ID，可以调佣系统函数创建进程组。
	“会话”(session):是一个或者多个进程组的集合
	一般，一个bash上面运行的所有程序都会属于一个会话，会有一个首进程，这个bsh通常就是首进程
	ps -eo pid,ppid,sid,tty,pgrp,comm,cmd | grep -E 'bash|PID|nginx'
	如果xshell终端要断开，系统会发送SIGHUP(终端断开信号)，给session leader
	bash进程收到SIGHUP信号后，会把信号发送给session里面的所有进程
	进程收到SIGHUP信号之后就会退出

	3.strace工具使用
	linux下调试分析诊断工具，可以跟踪程序执行时进程的系统调用以及收到的信号
	跟踪nginx进程：sudo strace -e trace=signal -p 1245
	kill(4294966051, SIGHUP):发送信号SIGHUP给进程组-1245的绝对值里所有的进程
	综合来讲，bash先发SIGHUP给session里面的所有进程，然后在发送SIGHUP给自己

	4.终端关闭时如何让进程不退出
	编写代码忽略SIGHUP信号
	nginx和bash不在同一个session里
	setsid命令，启动一个进程而且会使该进程会在一个新的session里面：setsid ./nginx
	nohup(不要挂断)：nohup ./nginx, 把屏幕输出重定位到nohup.out文件中去

	5.后台运行
	./nginx &:执行程序的同时，终端可以做其他的事情，如果不用后台执行，终端只能等待当前终端之后才能执行其他命令
	后台ctrl+c杀不掉
	fg切换到前台，bg切换到后台

/**************3.3：信号的概念、认识、处理动作*******************/
异步
sudo find / -name "signal.h" | xargs grep -in "SIGHUP"
进程状态：S+ Ss

/**************3.4：linux体系结构，信号编程初步*******************/
体系结构：应用进程->shell->系统调用->内核
	类unix操作系统分为两个状态：用户态，内核态
	操作系统/内核:用来控制计算机硬件资源，为程序运行提供环境
	我们写的程序要么运行在用户态，要么运行在内核态，一般运行在用户态
	当程序执行一些特殊代码时，程序可能切换到内核态，这些操作由操作系统完成

	系统调用：系统函数

	Shell和bash:bash(borne again shell（重置你装配的shell），shell的一种，linux默认采用bash)
	bash是一个可执行程序，是一种命令解释器，将用户输入的命令解释给操作系统
	分隔应用程序和系统调用，有胶水的感觉

	用户态内核态之间的切换
	运行于用户态的进程执行的操作受到限制，权限小
	运行于内核态可以执行任何操作，权限大
	一个进程执行的时候大部分时间是出于用户态下的，只有需要内核提供的服务时，才会切换到内核态，事情做完后又会切换到用户态

	进程区分用户态和内核态的原因：
	一般情况下，程序运行在用户态状态，权限小，不至于危害到系统其它部分。系统提供接口让你去干危险的事情
	既然这些接口是系统给你的，这些接口也是操作系统管理的，防止访问冲突，资源耗尽。

	什么时候从用户态切换到内核态：
	系统调用：比如malloc()
	异常事件：比如来了个信号
	外围设备中断：

signal函数范例：
	信号来了之后介意忽略可以捕捉。可以用signal函数来处理：signal(SIGUSER1,sig_usr), kill -USR1 1234
	内核知道你的程序收到了信号并知道你有信号处理函数

	1.可重入函数
	所谓的可重入函数，就是我们在信号处理函数中调用它是安全的，异步调用安全
	一些大家周知的函数式不可重入的，比如：malloc().printf()
	在信号处理函数中尽量使用简单的语句做简单的事情，尽量不要调用系统函数
	如果必须在信号处理函数中调用系统函数，那么系统函数一定要是可重入的

	signal因为兼容性问题，官方不建议使用，使用sigaction()函数代替

/**************3.5：信号编程进阶、sigprocmask范例*******************/

/**************3.6：fork函数详解，范例演示*******************/
fork()函数
